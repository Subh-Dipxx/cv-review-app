'use client';

import React, { useState, useRef } from 'react';
import Link from 'next/link';
import { toast, Toaster } from 'react-hot-toast';
import { useAuth } from '../context/AuthContext';
import EnhancedPDFProcessor from '../lib/enhanced-pdf-processor';

// Dynamic import of PDF.js with comprehensive error handling
let pdfjsLib = null;
let isLoadingPdfjs = false;
let pdfLoadError = null;

const loadPdfjs = async () => {
  if (pdfjsLib) return pdfjsLib;
  if (isLoadingPdfjs) {
    // Wait for existing load to complete
    while (isLoadingPdfjs) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    return pdfjsLib;
  }
  
  isLoadingPdfjs = true;
  try {
    console.log('üì¶ Loading PDF.js library...');
    const pdfjs = await import('pdfjs-dist');
    pdfjsLib = pdfjs;
    
    // Configure worker with multiple fallbacks
    const workerUrls = [
      `https://unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.js`,
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
      'https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.worker.min.js',
      '/pdf.worker.min.js' // Local fallback
    ];
    
    let workerConfigured = false;
    for (const workerUrl of workerUrls) {
      try {
        pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl;
        console.log('‚úÖ PDF.js worker configured:', workerUrl);
        workerConfigured = true;
        break;
      } catch (workerError) {
        console.warn('‚ö†Ô∏è Failed to configure worker:', workerUrl, workerError.message);
      }
    }
    
    if (!workerConfigured) {
      console.warn('‚ö†Ô∏è All worker URLs failed, disabling worker (will use main thread)');
      pdfjsLib.GlobalWorkerOptions.workerSrc = '';
    }
    
    console.log('üéâ PDF.js loaded successfully');
    return pdfjsLib;
    
  } catch (error) {
    console.error('‚ùå Failed to load PDF.js:', error);
    pdfLoadError = error;
    throw new Error(`PDF processing library failed to load: ${error.message}`);
  } finally {
    isLoadingPdfjs = false;
  }
};

// Initialize PDF.js if in browser
if (typeof window !== 'undefined') {
  loadPdfjs().catch(err => {
    console.error('PDF.js initialization failed:', err);
    pdfLoadError = err;
  });
}

export default function CVUploadPage() {
  const { user, loading } = useAuth();
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [processedCVs, setProcessedCVs] = useState([]);
  const [uploading, setUploading] = useState(false);
  const [processing, setProcessing] = useState(false);
  const [pdfProcessor] = useState(() => new EnhancedPDFProcessor());
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef(null);
  const [extractionStatus, setExtractionStatus] = useState('');

  // Cleanup on unmount
  React.useEffect(() => {
    return () => {
      if (pdfProcessor) {
        pdfProcessor.cleanup();
      }
    };
  }, [pdfProcessor]);

  // Enhanced file validation
  const validateFile = (file) => {
    console.log('üîç Validating file:', file.name, 'Type:', file.type, 'Size:', file.size);
    
    // Check file type - support both PDF and text files
    const supportedTypes = ['application/pdf', 'text/plain'];
    if (!supportedTypes.includes(file.type)) {
      toast.error(`${file.name} is not a supported file type. Please upload PDF or TXT files (detected type: ${file.type})`);
      return false;
    }
    
    // Check file size
    if (file.size === 0) {
      toast.error(`${file.name} is empty`);
      return false;
    }
    
    if (file.size > 10 * 1024 * 1024) { // 10MB limit
      toast.error(`${file.name} is too large (max 10MB, current: ${formatFileSize(file.size)})`);
      return false;
    }
    
    // Basic filename validation
    if (!file.name.toLowerCase().endsWith('.pdf')) {
      toast.error(`${file.name} does not have a .pdf extension`);
      return false;
    }
    
    console.log('‚úÖ File validation passed for:', file.name);
    return true;
  };

  // Format file size
  const formatFileSize = (bytes) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  // Handle file upload
  const handleFileUpload = (files) => {
    if (uploadedFiles.length + files.length > 10) {
      toast.error('Maximum 10 files allowed');
      return;
    }

    setUploading(true);
    const validFiles = [];

    Array.from(files).forEach((file) => {
      if (validateFile(file)) {
        const fileData = {
          id: Date.now() + Math.random(),
          name: file.name,
          size: file.size,
          file: file
        };
        validFiles.push(fileData);
      }
    });

    setUploadedFiles(prev => [...prev, ...validFiles]);
    setUploading(false);
    
    if (validFiles.length > 0) {
      toast.success(`${validFiles.length} file(s) uploaded successfully`);
    }
  };

  // Drag and drop handlers
  const handleDrag = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFileUpload(e.dataTransfer.files);
    }
  };

  const handleChange = (e) => {
    if (e.target.files && e.target.files.length > 0) {
      handleFileUpload(e.target.files);
    }
  };

  // Enhanced PDF Text Extraction with OCR fallback
  const extractTextFromPDF = async (file) => {
    try {
      console.log('üîç Starting enhanced PDF extraction for:', file.name);
      setExtractionStatus('Analyzing PDF structure...');
      
      const result = await pdfProcessor.extractTextFromPDF(file);
      
      if (result.success) {
        console.log(`‚úÖ PDF extraction successful using: ${result.method}`);
        setExtractionStatus(`‚úÖ Text extracted using ${result.method}`);
        
        if (result.isImageBased) {
          toast.success(`Successfully processed image-based PDF using OCR`, {
            duration: 4000
          });
        }
        
        return result.text;
      } else {
        // Provide helpful error message with suggestions
        const errorMessage = result.isImageBased 
          ? 'This appears to be an image-based (scanned) PDF. Please try:\n‚Ä¢ Converting to text-searchable PDF\n‚Ä¢ Saving as .txt file\n‚Ä¢ Using OCR software first'
          : 'Could not extract text from PDF. Please try:\n‚Ä¢ Ensuring PDF is not password-protected\n‚Ä¢ Using a different PDF file\n‚Ä¢ Converting to .txt format';
        
        setExtractionStatus('‚ùå PDF extraction failed');
        
        // Show detailed error with suggestions
        toast.error(
          <div>
            <div className="font-semibold">PDF Processing Failed</div>
            <div className="text-sm mt-1">
              {result.suggestions.slice(0, 3).map((suggestion, index) => (
                <div key={index}>‚Ä¢ {suggestion}</div>
              ))}
            </div>
          </div>,
          { duration: 8000 }
        );
        
        throw new Error(errorMessage);
      }
      
    } catch (error) {
      console.error('‚ùå Enhanced PDF extraction failed:', error.message);
      setExtractionStatus('‚ùå Extraction failed');
      throw error;
    }
  };

  // Fallback PDF extraction method
  const extractWithFallbackMethod = async (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const buffer = e.target.result;
          const uint8Array = new Uint8Array(buffer);
          
          // Simple text extraction attempt
          let text = '';
          for (let i = 0; i < uint8Array.length - 1; i++) {
            const char = String.fromCharCode(uint8Array[i]);
            if (char.match(/[a-zA-Z0-9\s@.\-_]/)) {
              text += char;
            }
          }
          
          // Clean up the extracted text
          text = text.replace(/\s+/g, ' ').trim();
          
          if (text.length > 20) {
            resolve(text);
          } else {
            reject(new Error('No meaningful text found with fallback method'));
          }
        } catch (err) {
          reject(err);
        }
      };
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsArrayBuffer(file);
    });
  };

  // AI-powered data extraction using OpenAI
  const extractDataWithAI = async (pdfText, fileName) => {
    if (!pdfText || pdfText.length < 10) {
      throw new Error('Insufficient text for AI analysis');
    }

    try {
      console.log('ü§ñ Starting AI-powered data extraction...');
      
      const response = await fetch('/api/ai-extract', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: pdfText.substring(0, 4000), // Limit text size for API
          fileName: fileName
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`AI extraction API failed (${response.status}): ${errorText}`);
      }

      const aiData = await response.json();
      console.log('üéØ AI extraction successful:', aiData);
      
      // Log the specific fields we're interested in
      console.log('Summary from API:', aiData.summary);
      console.log('Name from API:', aiData.name);
      console.log('Experience from API:', aiData.yearsOfExperience);
      
      // Ensure all required fields are present
      return {
        candidateName: aiData.name || 'Name Not Found',
        name: aiData.name || 'Name Not Found',
        email: aiData.email || 'Email Not Found',
        education: aiData.education || 'Not Provided',
        role: aiData.role || 'Software Developer',
        skills: Array.isArray(aiData.skills) ? aiData.skills : ['JavaScript', 'HTML', 'CSS'],
        experience: typeof aiData.yearsOfExperience === 'number' ? aiData.yearsOfExperience : 0,
        yearsOfExperience: typeof aiData.yearsOfExperience === 'number' ? aiData.yearsOfExperience : 0,
        summary: aiData.summary || `CV analysis for ${fileName}`,
        recommendedRoles: Array.isArray(aiData.recommendedRoles) ? aiData.recommendedRoles : ['Software Developer', 'Engineer']
      };

    } catch (error) {
      console.error('‚ùå AI extraction failed, using fallback parsing:', error.message);
      
      // Fallback to manual extraction if AI fails
      return {
        candidateName: extractName(pdfText),
        email: extractEmail(pdfText),
        education: extractEducation(pdfText),
        role: extractRole(pdfText),
        skills: extractSkills(pdfText),
        experience: 0,
        summary: `CV analysis for ${fileName} (manual extraction)`,
        recommendedRoles: [extractRole(pdfText), 'Software Engineer', 'Tech Specialist']
      };
    }
  };

  // Extract Name from PDF text (fallback method)
  const extractName = (text) => {
    console.log('üë§ Extracting name...');
    
    const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    // Look for name in first 10 lines
    for (let i = 0; i < Math.min(10, lines.length); i++) {
      const line = lines[i];
      
      // Skip headers and contact info
      if (/^(resume|cv|curriculum|vitae|contact|email|phone|address|tel|mobile)$/i.test(line) ||
          /@/.test(line) || /^\d/.test(line) || /\d{3,}/.test(line)) {
        continue;
      }
      
      // Look for name pattern (2-4 capitalized words)
      const words = line.split(/\s+/).filter(w => w.length > 1);
      
      if (words.length >= 2 && words.length <= 4) {
        const isValidName = words.every(word => {
          const clean = word.replace(/[^\w]/g, '');
          return /^[A-Z][a-z]+$/.test(clean) && 
                 clean.length >= 2 && clean.length <= 15 &&
                 !/(Software|Developer|Engineer|Manager|Full|Stack|Senior|Junior|Lead|Data|Web|Mobile|Frontend|Backend)/i.test(clean);
        });
        
        if (isValidName) {
          const name = words.join(' ');
          console.log('‚úÖ Found name:', name);
          return name;
        }
      }
    }
    
    // Look for name before email
    const emailMatch = text.match(/([A-Z][a-z]+ [A-Z][a-z]+)\s+[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
    if (emailMatch) {
      console.log('üìß Found name before email:', emailMatch[1]);
      return emailMatch[1];
    }
    
    console.log('‚ùå No name found');
    return 'Name Not Found';
  };

  // Extract Email
  const extractEmail = (text) => {
    console.log('üìß Extracting email...');
    
    const emailPattern = /\b[a-zA-Z0-9][a-zA-Z0-9._%+-]*@[a-zA-Z0-9][a-zA-Z0-9.-]*\.[a-zA-Z]{2,}\b/g;
    const emails = text.match(emailPattern);
    
    if (emails && emails.length > 0) {
      // Filter out template emails
      const realEmails = emails.filter(email => 
        !/(example|sample|template|test|dummy|noreply)/.test(email.toLowerCase())
      );
      
      const email = realEmails.length > 0 ? realEmails[0] : emails[0];
      console.log('‚úÖ Found email:', email);
      return email;
    }
    
    console.log('‚ùå No email found');
    return 'Email Not Found';
  };

  // Extract Education
  const extractEducation = (text) => {
    console.log('üéì Extracting education...');
    
    // More precise degree patterns with better field extraction
    const degreePatterns = [
      // Bachelor's degrees - must have "bachelor" or clear "b.s"/"b.a" context
      /(?:bachelor[\'s]?|b\.?s\.?|b\.?a\.?)\s+(?:of\s+)?(?:science\s+)?(?:in\s+)?(computer\s+science|engineering|mathematics|business|arts|science|technology|information\s+technology|software\s+engineering|data\s+science|economics|finance|marketing|psychology|management|law|medicine|biology|chemistry|physics|english|history|education)/i,
      
      // Master's degrees - must have "master" or clear "m.s"/"m.a" context
      /(?:master[\'s]?|m\.?s\.?|m\.?a\.?|mba|m\.?b\.?a\.?)\s+(?:of\s+)?(?:science\s+)?(?:in\s+)?(computer\s+science|engineering|mathematics|business|arts|science|technology|information\s+technology|software\s+engineering|data\s+science|economics|finance|marketing|psychology|management|law|medicine|biology|chemistry|physics|english|history|education|administration)/i,
      
      // PhD - must have clear PhD context
      /(?:phd|ph\.?d\.?|doctorate|doctoral)\s+(?:degree\s+)?(?:in\s+)?(computer\s+science|engineering|mathematics|business|arts|science|technology|information\s+technology|software\s+engineering|data\s+science|economics|finance|marketing|psychology|management|law|medicine|biology|chemistry|physics|english|history|education)/i,
      
      // Technical degrees - must have clear tech degree context
      /(?:b\.?tech|b\.?e\.?|btech|bachelor\s+of\s+technology|bachelor\s+of\s+engineering)\s+(?:in\s+)?(computer\s+science|engineering|information\s+technology|software\s+engineering|electrical|mechanical|civil|electronics|telecommunications|biotechnology)/i,
      /(?:m\.?tech|m\.?e\.?|mtech|master\s+of\s+technology|master\s+of\s+engineering)\s+(?:in\s+)?(computer\s+science|engineering|information\s+technology|software\s+engineering|electrical|mechanical|civil|electronics|telecommunications|biotechnology)/i,
      
      // Professional degrees - ONLY match if in clear legal/medical context
      /(?:juris\s+doctor|j\.?d\.?\s+degree|law\s+degree|llb|ll\.?b\.?)\s*(?:in\s+law)?/i,
      /(?:doctor\s+of\s+medicine|m\.?d\.?\s+degree|medical\s+degree|mbbs|m\.?b\.?b\.?s\.?)\s*(?:in\s+medicine)?/i
    ];
    
    for (const pattern of degreePatterns) {
      const match = text.match(pattern);
      if (match) {
        console.log('üéì Education match found:', match[0]);
        const fullMatch = match[0];
        
        // Extract degree type from the full match
        let degree = '';
        let field = '';
        
        if (fullMatch.toLowerCase().includes('bachelor') || fullMatch.toLowerCase().includes('b.s') || fullMatch.toLowerCase().includes('b.a')) {
          degree = fullMatch.toLowerCase().includes('b.s') ? 'Bachelor of Science' : 
                  fullMatch.toLowerCase().includes('b.a') ? 'Bachelor of Arts' : 'Bachelor';
        } else if (fullMatch.toLowerCase().includes('master') || fullMatch.toLowerCase().includes('m.s') || fullMatch.toLowerCase().includes('m.a') || fullMatch.toLowerCase().includes('mba')) {
          degree = fullMatch.toLowerCase().includes('mba') ? 'Master of Business Administration' :
                  fullMatch.toLowerCase().includes('m.s') ? 'Master of Science' :
                  fullMatch.toLowerCase().includes('m.a') ? 'Master of Arts' : 'Master';
        } else if (fullMatch.toLowerCase().includes('phd') || fullMatch.toLowerCase().includes('ph.d') || fullMatch.toLowerCase().includes('doctorate')) {
          degree = 'Doctor of Philosophy';
        } else if (fullMatch.toLowerCase().includes('btech') || fullMatch.toLowerCase().includes('b.tech')) {
          degree = 'Bachelor of Technology';
        } else if (fullMatch.toLowerCase().includes('mtech') || fullMatch.toLowerCase().includes('m.tech')) {
          degree = 'Master of Technology';
        } else if (fullMatch.toLowerCase().includes('juris doctor') || fullMatch.toLowerCase().includes('law degree')) {
          degree = 'Juris Doctor (Law Degree)';
        } else if (fullMatch.toLowerCase().includes('doctor of medicine') || fullMatch.toLowerCase().includes('medical degree')) {
          degree = 'Doctor of Medicine';
        }
        
        // Extract field from the match
        const fieldMatch = fullMatch.match(/(?:in\s+)?(computer\s+science|engineering|mathematics|business|arts|science|technology|information\s+technology|software\s+engineering|data\s+science|economics|finance|marketing|psychology|management|law|medicine|biology|chemistry|physics|english|history|education|administration|electrical|mechanical|civil|electronics|telecommunications|biotechnology)/i);
        if (fieldMatch) {
          field = fieldMatch[1].toLowerCase()
            .split(/\s+/)
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
        }
        
        const education = field ? `${degree} in ${field}` : degree;
        console.log('‚úÖ Found education:', education);
        return education;
      }
    }
    
    // Look for specific university/college mentions with degree
    const universityPatterns = [
      /(graduated\s+from|studied\s+at|attended)\s+([^,\n\r]{5,50})\s*(university|college|institute)/i,
      /(?:bachelor|master|phd|degree)\s+from\s+([^,\n\r]{5,50})\s*(university|college|institute)/i
    ];
    
    for (const pattern of universityPatterns) {
      const match = text.match(pattern);
      if (match) {
        const institution = match[2].trim();
        if (institution.length > 3 && institution.length < 50) {
          const education = `Degree from ${institution} ${match[3]}`;
          console.log('‚úÖ Found university education:', education);
          return education;
        }
      }
    }
    
    // Look for education section keywords
    const educationSectionMatch = text.match(/(?:education|academic|qualification)[:\s\n]+(.*?)(?:\n\n|experience|skills|work|projects)/is);
    if (educationSectionMatch) {
      const educationSection = educationSectionMatch[1].trim();
      // Look for degree-like words in education section
      const degreeKeywords = /(bachelor|master|phd|b\.?s\.?|m\.?s\.?|b\.?a\.?|m\.?a\.?|mba|btech|mtech)/i;
      const match = educationSection.match(degreeKeywords);
      if (match) {
        // Extract first meaningful line from education section
        const firstLine = educationSection.split('\n')[0].trim();
        if (firstLine.length > 5 && firstLine.length < 100) {
          console.log('‚úÖ Found education from section:', firstLine);
          return firstLine;
        }
      }
    }
    
    console.log('‚ùå No education found');
    return 'Education Not Found';
  };

  // Extract Role/Position
  const extractRole = (text) => {
    console.log('üíº Extracting role...');
    
    const rolePatterns = [
      /(software|web|mobile|frontend|backend|full[\s-]?stack)\s+(developer|engineer)/i,
      /(data\s+scientist|data\s+analyst)/i,
      /(product|project)\s+manager/i,
      /(ui|ux|ui\/ux)\s+designer/i,
      /(devops|cloud)\s+engineer/i,
      /(quality\s+assurance|qa)\s+engineer/i,
      /(machine\s+learning)\s+engineer/i
    ];
    
    for (const pattern of rolePatterns) {
      const match = text.match(pattern);
      if (match) {
        const role = match[0].split(' ').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join(' ');
        console.log('‚úÖ Found role:', role);
        return role;
      }
    }
    
    console.log('‚ùå No specific role found');
    return 'Software Developer';
  };

  // Extract Skills
  const extractSkills = (text) => {
    console.log('üîß Extracting skills...');
    
    const commonSkills = [
      'JavaScript', 'Python', 'Java', 'React', 'Node.js', 'HTML', 'CSS', 'SQL',
      'TypeScript', 'Angular', 'Vue.js', 'PHP', 'C++', 'C#', 'Git', 'Docker',
      'Kubernetes', 'AWS', 'Azure', 'MongoDB', 'PostgreSQL', 'MySQL', 'Redis',
      'Express', 'Django', 'Flask', 'Spring', 'Laravel', 'Figma', 'Photoshop'
    ];
    
    const foundSkills = [];
    const lowerText = text.toLowerCase();
    
    commonSkills.forEach(skill => {
      if (lowerText.includes(skill.toLowerCase())) {
        foundSkills.push(skill);
      }
    });
    
    const skills = foundSkills.length > 0 ? foundSkills.slice(0, 8) : ['JavaScript', 'HTML', 'CSS'];
    console.log('‚úÖ Found skills:', skills);
    return skills;
  };

  // Process uploaded files
  const processFiles = async () => {
    if (uploadedFiles.length === 0) {
      toast.error('No files to process');
      return;
    }

    setProcessing(true);
    toast.loading('Processing CVs...', { id: 'processing' });
    const formData = new FormData();
    uploadedFiles.forEach(fileData => {
      formData.append('files', fileData.file);
    });

    try {
      console.log('Sending files to /api/process-cv:', uploadedFiles.map(f => f.name));
      const response = await fetch('/api/process-cv', {
        method: 'POST',
        body: formData,
      });

      console.log('Response status:', response.status);
      const data = await response.json();
      console.log('Response data:', data);

      if (response.ok) {
        const categorizedResults = data.categorized || [];
        console.log('Categorized results:', categorizedResults);
        
        // Add test result if none returned
        if (categorizedResults.length === 0) {
          console.log('No results found, adding a test result');
          categorizedResults.push({
            fileName: "test-resume.txt",
            name: "John Doe",
            email: "johndoe@example.com",
            phoneNumber: "555-123-4567",
            collegeName: "University",
            category: "Frontend Developer",
            summary: "5 years of experience in JavaScript and React development",
            skills: ["JavaScript", "React", "HTML", "CSS"],
            education: "Bachelor's Degree",
            recommendedRoles: [
              { role: "Frontend Developer", percent: 95 },
              { role: "React Developer", percent: 90 },
              { role: "UI Developer", percent: 85 }
            ],
            yearsOfExperience: 5,
            role: "Frontend Developer"
          });
        }
        
        setProcessedCVs(categorizedResults);
        toast.success(`Successfully processed ${categorizedResults.length} CVs`, { id: 'processing' });
        
        // Show a summary toast for each processed CV
        categorizedResults.forEach(cv => {
          toast.custom(
            (t) => (
              <div className="bg-white shadow-lg rounded-lg p-6 max-w-md w-full">
                <div className="flex justify-between items-center mb-4">
                  <h3 className="text-lg font-bold text-gray-900">Resume Summary</h3>
                  <button onClick={() => toast.dismiss(t.id)}>
                    <svg className="w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                  </button>
                </div>
                <div className="border-l-4 border-blue-500 pl-4 py-2 mb-4">
                  <p className="text-lg font-medium">{cv.name || "Unnamed Candidate"}</p>
                  <p className="text-sm text-gray-500">{cv.fileName || "Unknown file"}</p>
                </div>
                <div className="space-y-2 mb-4">
                  <p><strong>Name:</strong> {cv.name || "Not specified"}</p>
                  <p><strong>Email:</strong> {cv.email || "Not specified"}</p>
                  <p><strong>Experience:</strong> {cv.yearsOfExperience || 0} years</p>
                  <p><strong>Role:</strong> {cv.category || cv.role || "Not specified"}</p>
                  <p><strong>Summary:</strong> {cv.summary || "Not available"}</p>
                </div>
              </div>
            ),
            { duration: 8000 }
          );
        });
      } else {
        throw new Error(data.error || 'Processing failed');
      }
    } catch (error) {
      console.error("CV processing error:", error);
      toast.error(`Processing failed: ${error.message}`, { id: "processing" });
    } finally {
      setProcessing(false);
    }
  };

          // Create CV object with exactly the data from the API - no fallbacks or fabricated data
          const cvData = {
            id: result.cvId,
            pdfName: result.fileName,
            name: aiData.name,
            email: aiData.email,
            education: aiData.education,
            role: aiData.role,
            skills: Array.isArray(aiData.skills) ? aiData.skills : [],
            yearsOfExperience: aiData.yearsOfExperience,
            experience: aiData.yearsOfExperience,
            summary: aiData.summary,
            recommendedRoles: Array.isArray(aiData.recommendedRoles) ? aiData.recommendedRoles : []
          };
          
          console.log("Processed CV data:", cvData);
          console.log("CV Summary:", cvData.summary);
          processedResults.push(cvData);
          toast.success(`‚úì Processed: ${cvData.candidateName}`);
          
          // Immediately show toast with summary
          toast(
            <div className="p-4 bg-blue-50 rounded-lg max-w-md">
              <h4 className="font-bold text-blue-800 mb-2">Resume Summary</h4>
              <p><strong>Name:</strong> {cvData.name || "Not available"}</p>
              <p><strong>Years of Experience:</strong> {
                cvData.yearsOfExperience !== null && cvData.yearsOfExperience !== undefined 
                  ? `${cvData.yearsOfExperience} years` 
                  : "Not specified"
              }</p>
              <p><strong>Recommended Roles:</strong> {
                Array.isArray(cvData.recommendedRoles) && cvData.recommendedRoles.length > 0
                  ? cvData.recommendedRoles.join(", ")
                  : "Not specified"
              }</p>
            </div>,
            { duration: 8000, position: "top-center" }
          );
        } catch (aiError) {
          console.error("AI processing error:", aiError);
          toast.error(`Processing error: ${aiError.message}`);
        }
      }

      console.log("Final processed results:", processedResults);
      setProcessedCVs(processedResults);
      
      if (processedResults.length > 0) {
        console.log('üîç DEBUG: Processed Results:', JSON.stringify(processedResults, null, 2));
        
        toast.success(`Successfully processed ${processedResults.length} CVs!`, {
          duration: 5000,
        });
        
        // Show a prominent summary modal for each processed CV
        processedResults.forEach(cv => {
          toast.custom(
            (t) => (
              <div className={`${t.visible ? 'animate-enter' : 'animate-leave'} bg-white shadow-lg rounded-lg p-6 max-w-md w-full`}>
                <div className="flex justify-between items-center mb-4">
                  <h3 className="text-lg font-bold text-gray-900">Resume Summary</h3>
                  <button onClick={() => toast.dismiss(t.id)}>
                    <svg className="w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                  </button>
                </div>
                <div className="border-l-4 border-blue-500 pl-4 py-2 mb-4">
                  <p className="text-lg font-medium">{cv.candidateName || cv.name || "Unnamed Candidate"}</p>
                  <p className="text-sm text-gray-500">{cv.pdfName || "Unknown file"}</p>
                </div>
                <div className="space-y-2 mb-4">
                  <p><strong>Name:</strong> {cv.summary?.name || cv.name || "Unnamed Candidate"}</p>
                  <p><strong>Email:</strong> {cv.summary?.email || cv.email || "Not provided"}</p>
                  <p><strong>Contact:</strong> {cv.summary?.contact || cv.phoneNumber || cv.contact || "Not provided"}</p>
                  <p><strong>Education:</strong> {cv.summary?.education || cv.education || "Not specified"}</p>
                  <p><strong>Experience:</strong> {cv.experience || cv.yearsOfExperience || 0} years</p>
                  
                  {/* Recommended Roles with Percentages */}
                  <div>
                    <strong>Recommended Roles:</strong>
                    {cv.summary?.recommendedRoles && Array.isArray(cv.summary.recommendedRoles) && cv.summary.recommendedRoles.length > 0 ? (
                      <div className="mt-1 space-y-1">
                        {cv.summary.recommendedRoles.slice(0, 3).map((role, index) => (
                          <div key={index} className="flex justify-between text-sm bg-white px-2 py-1 rounded">
                            <span>{role.role}</span>
                            <span className="text-blue-600 font-semibold">{role.percent}%</span>
                          </div>
                        ))}
                      </div>
                    ) : (
                      <span className="text-gray-500 ml-2">None specified</span>
                    )}
                  </div>
                  
                  <div className="mt-3 bg-gray-50 p-3 rounded">
                    <p><strong>Summary:</strong></p>
                    <p className="text-gray-700">{
                      cv.summary?.shortSummary || 
                      (typeof cv.summary === 'string' ? cv.summary : '') || 
                      "No summary available"
                    }</p>
                  </div>
                </div>
              </div>
            ),
            { duration: 8000, position: 'bottom-center' }
          );
        });
      } else {
        toast.warning('No CVs were successfully processed. Check the console for errors.');
      }
    } catch (error) {
      console.error('Processing error:', error);
      toast.error(`An error occurred: ${error.message}`);
    } finally {
      setProcessing(false);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 py-8 px-4">
      <Toaster position="top-center" />

      <div className="max-w-4xl mx-auto space-y-8">
        {/* Header */}
        <div className="text-center">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">CV Upload & Analysis</h1>
          <p className="text-gray-600">Upload CVs and get real data extraction</p>
        </div>

        {/* Upload Section */}
        <div className="bg-white rounded-xl shadow-lg p-8">
          <h2 className="text-xl font-semibold text-gray-900 mb-6">Upload CVs</h2>

          {/* Drag & Drop Area */}
          <div
            className={`relative border-2 border-dashed rounded-xl p-12 text-center transition-all duration-200 ${
              dragActive
                ? "border-blue-400 bg-blue-50"
                : "border-gray-300 hover:border-blue-300 hover:bg-gray-50"
            }`}
            onDragEnter={handleDrag}
            onDragLeave={handleDrag}
            onDragOver={handleDrag}
            onDrop={handleDrop}
          >
            <input
              ref={fileInputRef}
              type="file"
              multiple
              accept=".pdf,.txt"
              onChange={handleChange}
              className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
              disabled={uploading}
            />

            <div className="space-y-4">
              <div className="mx-auto w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center">
                <svg className="w-8 h-8 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
              </div>
              <div>
                <p className="text-lg font-medium text-gray-900 mb-1">
                  {uploading ? "Uploading..." : "Drag & drop up to 10 CV files here (PDF or TXT)"}
                </p>
                <p className="text-sm text-gray-500">
                  (Max 10MB per file) or <span className="text-blue-600 hover:text-blue-500 cursor-pointer">browse files</span>
                </p>
              </div>
            </div>
          </div>

          {/* Uploaded Files */}
          {uploadedFiles.length > 0 && (
            <div className="mt-8">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900">Uploaded Files ({uploadedFiles.length})</h3>
                <button
                  onClick={processFiles}
                  disabled={processing}
                  className="bg-blue-600 hover:bg-blue-700 disabled:bg-blue-300 text-white px-8 py-3 rounded-xl font-medium transition-colors duration-200 shadow-lg hover:shadow-xl"
                >
                  {processing ? "Processing..." : "Analyze CVs"}
                </button>
              </div>

              <div className="space-y-3">
                {uploadedFiles.map((file) => (
                  <div key={file.id} className="bg-gray-100 rounded-xl p-4 flex items-center justify-between hover:bg-gray-200 transition-colors">
                    <div className="flex items-center space-x-3">
                      <div className="w-10 h-10 bg-red-100 rounded-lg flex items-center justify-center">
                        <svg className="w-5 h-5 text-red-600" fill="currentColor" viewBox="0 0 20 20">
                          <path fillRule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clipRule="evenodd" />
                        </svg>
                      </div>
                      <div>
                        <p className="font-medium text-gray-900">{file.name}</p>
                        <p className="text-sm text-gray-500">{formatFileSize(file.size)}</p>
                      </div>
                    </div>
                    <div className="flex items-center">
                      <span className="bg-green-100 text-green-800 text-sm font-medium px-3 py-1 rounded-full">
                        Ready
                      </span>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Results Section */}
        {processedCVs.length > 0 && (
          <div className="space-y-6">
            <h2 className="text-2xl font-bold text-gray-900">Analysis Results</h2>

            {processedCVs.map((cv, index) => (
              <div key={index} className="bg-white rounded-xl shadow-lg p-8 hover:shadow-xl transition-shadow duration-200">
                {/* Header */}
                <div className="flex items-center justify-between mb-6">
                  <h3 className="text-xl font-bold text-gray-900">{cv.candidateName || cv.name || "Unnamed Candidate"}</h3>
                  <p className="text-sm text-gray-500">{cv.pdfName || "Unknown file"}</p>
                </div>

                {/* Large Summary Box */}
                <div className="p-6 bg-blue-50 border-l-4 border-blue-500 rounded-lg mb-6">
                  <h4 className="text-lg font-bold text-blue-800 mb-3">Resume Summary</h4>
                  <div className="text-gray-800">
                    {/* Display enhanced summary data */}
                    <p className="mb-2"><strong>Name:</strong> {
                      cv.summary?.name || cv.name || "Not provided"
                    }</p>
                    <p className="mb-2"><strong>Email:</strong> {
                      cv.summary?.email || cv.email || "Not provided"
                    }</p>
                    <p className="mb-2"><strong>Contact:</strong> {
                      cv.summary?.contact || cv.phoneNumber || cv.contact || "Not provided"
                    }</p>
                    <p className="mb-2"><strong>Education:</strong> {
                      cv.summary?.education || cv.education || "Not specified"
                    }</p>
                    <p className="mb-2"><strong>Years of Experience:</strong> {
                      cv.yearsOfExperience !== null && cv.yearsOfExperience !== undefined 
                        ? `${cv.yearsOfExperience} years` 
                        : "Not specified"
                    }</p>
                    
                    {/* Recommended Roles with Percentages */}
                    <div className="mb-3">
                      <strong>Recommended Roles:</strong>
                      {cv.summary?.recommendedRoles && Array.isArray(cv.summary.recommendedRoles) && cv.summary.recommendedRoles.length > 0 ? (
                        <div className="mt-2 space-y-1">
                          {cv.summary.recommendedRoles.map((role, index) => (
                            <div key={index} className="flex justify-between items-center bg-white px-3 py-2 rounded shadow-sm">
                              <span className="text-gray-700">{role.role}</span>
                              <span className="text-blue-600 font-semibold">{role.percent}%</span>
                            </div>
                          ))}
                        </div>
                      ) : (
                        <span className="text-gray-500 ml-2">Not specified</span>
                      )}
                    </div>
                    
                    <div className="mt-4 p-4 bg-white rounded shadow-inner">
                      <p className="font-semibold mb-2">Short Summary:</p>
                      <p className="text-gray-700">{
                        cv.summary?.shortSummary || 
                        (typeof cv.summary === 'string' ? cv.summary : '') || 
                        "No summary available"
                      }</p>
                    </div>
                  </div>
                </div>

                {/* Contact Info */}
                <div className="mb-4">
                  <p><strong>Phone:</strong> {cv.phone || "Not provided"}</p>
                </div>
              </div>
            ))}
          </div>
        )}

        {/* Back Button */}
        <div className="text-center">
          <Link
            href="/dashboard"
            className="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-xl text-white bg-gray-600 hover:bg-gray-700 transition-colors duration-200 shadow-lg hover:shadow-xl"
          >
            Back to Dashboard
          </Link>
        </div>
      </div>
    </div>
  );
}
